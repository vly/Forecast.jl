var documenterSearchIndex = {"docs":
[{"location":"","page":"Forecast","title":"Forecast","text":"CurrentModule = Forecast","category":"page"},{"location":"#Forecast","page":"Forecast","title":"Forecast","text":"","category":"section"},{"location":"","page":"Forecast","title":"Forecast","text":"","category":"page"},{"location":"","page":"Forecast","title":"Forecast","text":"Modules = [Forecast]","category":"page"},{"location":"#Forecast.Forecast","page":"Forecast","title":"Forecast.Forecast","text":"Collection of methods for Time Series analysis\n\nMethods implemented:\n\nacf:        Auto-correlation or auto-covariance of a univariate serie. \nccf:        Cross-correlation or cros-covariance of two univariate series.\nd:          Lagged differences of a given order for Vector, Array and TimeSeries.\nloess:      Locally weighted smoothed series.\nsma:        Simple moving average.\nstl:        Seasonal and Trend decomposition using loess.\n\n\n\n\n\n","category":"module"},{"location":"#Forecast.acf-Tuple{TimeSeries.TimeArray}","page":"Forecast","title":"Forecast.acf","text":"Package: Forecast\n\nfunction acf(x::{AbstractVector,TimeArray},              type = \"cor\",              lag = Integer(ceil(10*log10(length(x1)))),              alpha = (0.95,0.99))\n\nCompute the auto-correlation or auto-covariance for an univariate series.\n\nThe results are normalized preserve homoscedasticity. The distribution used to normalize the data is an approximation of a Fisher Transformation via a Normal Distribution. There is a plot recipe for the returned object, if the type is cor the plot will also show confidence intervals for the given alpha values.\n\nArgs:\n    `x`: Vector or uni-dimensional TimeArray of data.\n    `type`: Valid values are \"cor\" for correlation (default) and \"cov\" for convariance.\n    `lag`: Maximum number of lags.\n    `alpha`: A tuple with two thresholds (t1,t2) with t1 <= t2 to plot confidence intervals. The default values are 0.95 and 0.99.\nReturns:\n    Vector of auto-correlation or auto-covariance between two vectors \n    plus an optional plot with cofidence intervals\n\nExamples\n\njulia> x = rand(100);\nres = acf(x1; type=\"cor\");\nplot(res)\n\n\n\n\n\n","category":"method"},{"location":"#Forecast.ccf-Tuple{TimeSeries.TimeArray,TimeSeries.TimeArray}","page":"Forecast","title":"Forecast.ccf","text":"Package: Forecast\n\nfunction ccf(x1::{AbstractVector,TimeArray},              x2::{AbstractVector,TimeArray};              type = \"cor\",              lag = Integer(ceil(10*log10(length(x1)))),              alpha = (0.95,0.99))\n\nCompute the cross-correlation or cros-covariance of two univariate series.\n\nThe results are normalized preserve homoscedasticity. The distribution used to normalize the data is an approximation of a Fisher Transformation via a Normal Distribution. There is a plot recipe for the returned object, if the type is cor the plot will also show confidence intervals for the given alpha values.\n\nIf, for a given integer k, x2 repeats x1 values such that x1[t] = x2[t+k] for all i then high correlation value will be placed at the right from the center in the results. That is, this convention will be represented in the plots as x1_t = x2_{t+k} -> _____0__k__ meaning x2 behavior can be predicted by x1 in k units.\n\nArgs:\n    `x1`: Vector or uni-dimensional TimeArray of data.\n    `x2`: Vector or uni-dimensional TimeArray of data.\n    `type`: Valid values are \"cor\" for correlation (default) and \"cov\" for convariance.\n    `lag`: Maximum number of lags.\n    `alpha`: A tuple with two thresholds (t1,t2) with t1 <= t2 to plot confidence intervals. The default values are 0.95 and 0.99.\nReturns:\n    Vector of cross-correlation or cross-covariance between two vectors \n    plus an optional plot with cofidence intervals\n\nExamples\n\njulia> x1 = rand(100);\nx2 = circshift(x1,6);\nres = ccf(x1, x2; type=\"cor\");\nplot(res)\n\n\n\n\n\n","category":"method"},{"location":"#Forecast.co2","page":"Forecast","title":"Forecast.co2","text":"co2(full = false)\n\nReturn dataset with atmospheric Carbon Dioxide Dry Air Mole Fractions from quasi-continuous measurements at Mauna Loa, Hawaii.\n\nK.W. Thoning, A.M. Crotwell, and J.W. Mund (2020), Atmospheric Carbon Dioxide Dry Air Mole Fractions from continuous measurements at Mauna Loa, Hawaii, Barrow, Alaska, American Samoa and South Pole. 1973-2019, Version 2020-08 National Oceanic and Atmospheric Administration (NOAA), Global Monitoring Laboratory (GML), Boulder, Colorado, USA https://doi.org/10.15138/yaf1-bk21 FTP path: ftp://aftp.cmdl.noaa.gov/data/greenhouse_gases/co2/in-situ/surface/\n\nArgs:\n    `full`: if `true` Returns full original dataset from 1973 to 2020 in a DataFrame, otherwise returns the subset used in \"STL: A Seasonal-Trend Decomposition Procedure Based on Loess\" from Cleveland et. al.\nReturns:\n    Dataframe or TimeArray containing the descrived dataset.\n\nExamples\n\njulia> co2()\n[ Info: Dataset used in Cleveland et al. paper\n4609×1 TimeArray{Union{Missing, Float64},1,Date,Array{Union{Missing, Float64},1}} 1974-05-17 to 1986-12-31\n│            │ co2     │\n├────────────┼─────────┤\n│ 1974-05-17 │ 333.38  │\n│ 1974-05-18 │ 333.11  │\n│ 1974-05-19 │ 333.46  │\n   ⋮\n\n\n\n\n\n","category":"function"},{"location":"#Forecast.d","page":"Forecast","title":"Forecast.d","text":"function d(x::{AbstractVector,AbstractArray,TimeArray},            order::Int=1;            lag::Int=1,            center::Bool=true,            pad::Bool=true)\n\nReturn Lagged differences of a given order for Vector, Array and TimeSeries.\n\nArgs:\n    `x`: Vector or Array of data.\n    `order`: Order of the differences; number of recursive iterations\n             on the same vector/array.\n    `lag`: Lag for the difference.\n    `center`: Center the result in the response using Missing values.\n    `pad`: Includes or removes `missing` pad.\nReturns:\n    Lagged differences Vector or Array of a given order\n\nExamples\n\njulia> x = [1,2,3,4,5];\njulia> d(x)\n5-element Array{Any,1}:\n 1\n 1\n 1\n 1\n  missing\n\njulia> d(x,2)\n5-element Array{Any,1}:\n  missing\n 0\n 0\n 0\n  missing\n\njulia> d(x;lag=2,pad=false)\n3-element Array{Any,1}:\n 2\n 2\n 2\n\njulia> x = reshape(collect(1:20),10,2)\n10×2 Array{Int64,2}:\n  1  11\n  2  12\n  3  13\n  4  14\n  5  15\n  6  16\n  7  17\n  8  18\n  9  19\n 10  20 \n\njulia> d(x,2;lag=2,pad=false)\n6×2 Array{Any,2}:\n 0  0\n 0  0\n 0  0\n 0  0\n 0  0\n 0  0\n\njulia> d(co2())\n[ Info: Dataset used in Cleveland et al. paper\n4609×1 TimeArray{Any,1,Date,Array{Any,1}} 1974-05-17 to 1986-12-31\n│            │ A       │\n├────────────┼─────────┤\n│ 1974-05-17 │ -0.27   │\n│ 1974-05-18 │ 0.35    │\n│ 1974-05-19 │ 0.18    │\n   ⋮\n│ 1986-12-30 │ missing │\n│ 1986-12-31 │ missing │\n\n\n\n\n\n\n","category":"function"},{"location":"#Forecast.loess-Tuple{Any,Any}","page":"Forecast","title":"Forecast.loess","text":"function loess(xv,yv;                d=2,                q=Int64(round(3/4*length(xv))),                rho=repeat([1.0],inner=length(xv)),                  predict = xv)\n\nSmooth a vector of observations using locally weighted regressions.\n\nAlthough loess can be used to smooth observations for any given number of independent variables, this implementation is univariate. The speed of loess can be greatly increased by using fast aproximations for the linear fitting calculations, however this implementation calculates only exact results.\n\nThe loess functionality and nomenclature follows the descriptions in:\n\n\"STL: A Seasonal, Trend Decomposition Procedure Based on Loess\"\n Robert B. Cleveland, William S. Cleveland, Jean E. McRae, and Irma Terpenning.\n Journal of Official Statistics Vol. 6. No. 1, 1990, pp. 3-73 (c) Statistics Sweden.\n\nArgs:\n    `xv`: Observations' support.\n    `yv`: Observation values.\n    `d`: Degree of the linear fit, it accepts values 1 or 2.\n    `q`: As q increases loess becomes smoother, when q tends to infinity loess tends to an ordinary least square poynomial fit of degree `d`. It defaults to the rounding of 3/4 of xv's length.\n    `rho`: Weights expressing the reliability of the observations (e.g. if yi had variances sigma^2*ki where ki where known, the rhoi could be 1/ki). It defaults to 1.0.\n    `predict`: Vector containing the real values to be predicted, by default predicts xv.\nReturns:\n    The loess values for the values contained in `predict`.\n\nExamples\n\njulia> loess(rand(5),rand(5))\n5-element Array{Float64,1}:\n 0.8279856470091445\n 0.6498793177642597\n 0.017078421335739336\n 0.8595786774014016\n 0.2564676547690037\n\n\n\n\n\n","category":"method"},{"location":"#Forecast.nextodd-Tuple{Real}","page":"Forecast","title":"Forecast.nextodd","text":"nextodd(x)\n\nReturn the smallest odd integer greater than or equal to x.        \n\n\n\n\n\n","category":"method"},{"location":"#Forecast.sma-Tuple{Any,Any}","page":"Forecast","title":"Forecast.sma","text":"sma(x, n; center = true)\n\nSmooth a vector of data using a simple moving average.\n\nArgs:\n    `x`: Vector of data.\n    `n`: Size of the moving average.\n    `center`: centers the moving averaged values in the response.\nReturns:\n    Vector of moving average smoothed values containing `missing` values to preserve the size of the original vector.\n\nExamples\n\njulia> sma(1:5,3;center=true)\n5-element Array{Any,1}:\n  missing\n 2.0\n 3.0\n 4.0\n  missing\n\n\n\n\n\n","category":"method"},{"location":"#Forecast.stl-Tuple{TimeSeries.TimeArray,Integer}","page":"Forecast","title":"Forecast.stl","text":"stl(Yv, np; robust=false, \n            nl=nextodd(np), \n            ns=10*length(Yv)+1,\n            nt=nextodd(1.5*np/(1-1.5/ns)), \n            ni=robust ? 1 : 2,\n            no=0,\n            spm=false,\n            qsmp=max(div(np,7),2))\n\nDecompose a time series into trend, seasonal, and remainder components.\n\n\"STL has a simple design that consists of a sequence of applications of the loess smoother; the simplicity allows analysis of the properties of the procedure and allows fast computation, even for very long time series and large amounts of trend and seasonal smoothing. Other features of STL  are specification of amounts of seasonal and trend smoothing that range, in a nearly continous way, from very small amount of smoothing to a very large amount; robust estimates of the trend and seasonal components that are not distorted by aberrant behavior in the data; specification of the period of the seasonal component to any intenger multiple of the time sampling interval greater than one; and the ability to decompose time series with missing values.\"\n\nExcerpt from \"STL: A Seasonal, Trend Decomposition Procedure Based on Loess\"               Robert B. Cleveland, William S. Cleveland, Jean E. McRae, and Irma Terpenning.               Journal of Official Statistics Vol. 6. No. 1, 1990, pp. 3-73 (c) Statistics Sweden.\n\nAll default values are chosen following the recommendations of the original paper when those were recommended. ns is recommended to be chosen of the basis of knowledge of the time series and on the basis of diagnostic methods; it must nonethelessbe  always odd and at least 7. A default value is not advised on the original paper, instead the same default value used in the stl implementation in R in usere here.\n\nfor no the authors advise 5 (\"safe value\") or 10 (\"near certainty of convergence\") cycles  or a convergence criterion when robustness is required, in this case when robust is true computations stop when convergence is achieved in trend and seasonality.\n\nfor qsmp the authors do not adivise a default but they use a value close to div(np,7).\n\nArgs:\n    `np`: Seasonality.\n    `robust`: Robust stl.\n    `nl`: Smoothing parameter of the low-pass filter.\n    `ns`: Smoothing parameter for the seasonal component.\n    `nt`: Smoothing parameter for the trend decomposition.\n    `ni`: Number of inner loop cycles.\n    `no`: Number of outer loop cycles.\n    `spm`: Seasonal post-smoothing.\n    `qsmp`: Loess q window for Seasonal post-smoothing.\n    `verbose`: If true shows updates for the Seasonal and Trend convergence.\n    `cth`: Corvengence threshold for Seasonal and Trend.\nReturns:\n    An `stl` object with the seasonal, trend and remainder components if Yv is an Array and\n    a TimeSeries object with the same components if Yv is a TimeSeries.\n\nExamples\n\njulia> stl(co2(),365; robust=true, spm=true)\n[ Info: Dataset used in Cleveland et al. paper\n[ Info: Corvengence achieved (< 0.01); Stopping computation...\nSTL{TimeSeries.TimeArray{Union{Missing, Float64},2,Dates.Date,Array{Union{Missing, Float64},2}}}(4609×3 TimeSeries.TimeArray{Union{Missing, Float64},2,Dates.Date,Array{Union{Missing, Float64},2}} 1974-05-17 to 1986-12-31, \"stl(Yn, np=365; nl=365, ns=46091, nt=549, ni=1, no=0, spm=true, qsmp=52)\")\n\n\n\n\n\n","category":"method"}]
}
